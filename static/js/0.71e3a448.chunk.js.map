{"version":3,"sources":["../node_modules/@openchemistry/molecule/dist/esm/es5/build/gesture.js"],"names":["__webpack_require__","r","__webpack_exports__","d","createGesture","_sPassive","GestureController","doc","this","gestureId","requestedStart","Map","disabledGestures","disabledScroll","Set","capturedId","prototype","config","GestureDelegate","newID","name","priority","disableScroll","createBlocker","opts","BlockerDelegate","disable","start","gestureName","id","canStart","set","delete","capture","maxPriority","forEach","value","Math","max","clear","event","CustomEvent","detail","body","dispatchEvent","release","disableGesture","get","add","enableGesture","enableScroll","isDisabled","isCaptured","isScrollDisabled","size","disabled","ctrl","captured","destroy","undefined","block","_i","_b","length","gesture","unblock","gestureController","document","addEventListener","el","eventName","callback","remove","listenerOpts","node","Object","defineProperty","_a","supportsPassive","passive","MOUSE_WAIT","getDocument","Document","ownerDocument","finalConfig","assign","direction","gesturePriority","maxAngle","threshold","onWillStart","onStart","onEnd","notCaptured","onMove","queue","type","startX","startY","startTimeStamp","currentX","currentY","velocityX","velocityY","deltaX","deltaY","timeStamp","data","pointerEvents","pointerDown","pointerMove","pointerUp","options","rmTouchStart","rmTouchMove","rmTouchEnd","rmTouchCancel","rmMouseStart","rmMouseMove","rmMouseUp","lastTouchEvent","handleTouchStart","ev","Date","now","handleTouchEnd","handleMouseDown","console","debug","handleMouseUp","stopTouch","stopMouse","stop","setDisabled","createPointerEvents","hasStartedPan","hasFiredStart","updateDetail","tryToCapturePan","pan","hasCapturedPan","isMoveQueued","calcGestureData","write","fireOnMove","detect","isGesture","reset","tmpHasCaptured","tmpHasFiredStart","thresh","radians","PI","isDirX","maxCosine","cos","dirty","isPan","x","y","distance","hypotenuse","sqrt","cosine","getDirection","createPanRecognizer","then","fireOnStart","prevX","prevY","prevT","timeDelta","changedTouches","touch","clientX","clientY","pageX","pageY"],"mappings":"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","file":"static/js/0.71e3a448.chunk.js","sourcesContent":["var GestureController =\n/** @class */\nfunction () {\n  function GestureController(doc) {\n    this.doc = doc;\n    this.gestureId = 0;\n    this.requestedStart = new Map();\n    this.disabledGestures = new Map();\n    this.disabledScroll = new Set();\n    this.capturedId = null;\n  }\n  /**\n   * Creates a gesture delegate based on the GestureConfig passed\n   */\n\n\n  GestureController.prototype.createGesture = function (config) {\n    return new GestureDelegate(this, this.newID(), config.name, config.priority ? config.priority : 0, !!config.disableScroll);\n  };\n  /**\n   * Creates a blocker that will block any other gesture events from firing. Set in the ion-gesture component.\n   */\n\n\n  GestureController.prototype.createBlocker = function (opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return new BlockerDelegate(this.newID(), this, opts.disable, !!opts.disableScroll);\n  };\n\n  GestureController.prototype.start = function (gestureName, id, priority) {\n    if (!this.canStart(gestureName)) {\n      this.requestedStart.delete(id);\n      return false;\n    }\n\n    this.requestedStart.set(id, priority);\n    return true;\n  };\n\n  GestureController.prototype.capture = function (gestureName, id, priority) {\n    if (!this.start(gestureName, id, priority)) {\n      return false;\n    }\n\n    var requestedStart = this.requestedStart;\n    var maxPriority = -10000;\n    requestedStart.forEach(function (value) {\n      maxPriority = Math.max(maxPriority, value);\n    });\n\n    if (maxPriority === priority) {\n      this.capturedId = id;\n      requestedStart.clear();\n      var event = new CustomEvent('ionGestureCaptured', {\n        detail: gestureName\n      });\n      this.doc.body.dispatchEvent(event);\n      return true;\n    }\n\n    requestedStart.delete(id);\n    return false;\n  };\n\n  GestureController.prototype.release = function (id) {\n    this.requestedStart.delete(id);\n\n    if (this.capturedId && id === this.capturedId) {\n      this.capturedId = null;\n    }\n  };\n\n  GestureController.prototype.disableGesture = function (gestureName, id) {\n    var set = this.disabledGestures.get(gestureName);\n\n    if (!set) {\n      set = new Set();\n      this.disabledGestures.set(gestureName, set);\n    }\n\n    set.add(id);\n  };\n\n  GestureController.prototype.enableGesture = function (gestureName, id) {\n    var set = this.disabledGestures.get(gestureName);\n\n    if (set) {\n      set.delete(id);\n    }\n  };\n\n  GestureController.prototype.disableScroll = function (id) {\n    this.disabledScroll.add(id);\n  };\n\n  GestureController.prototype.enableScroll = function (id) {\n    this.disabledScroll.delete(id);\n  };\n\n  GestureController.prototype.canStart = function (gestureName) {\n    if (this.capturedId) {\n      // a gesture already captured\n      return false;\n    }\n\n    if (this.isDisabled(gestureName)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  GestureController.prototype.isCaptured = function () {\n    return !!this.capturedId;\n  };\n\n  GestureController.prototype.isScrollDisabled = function () {\n    return this.disabledScroll.size > 0;\n  };\n\n  GestureController.prototype.isDisabled = function (gestureName) {\n    var disabled = this.disabledGestures.get(gestureName);\n\n    if (disabled && disabled.size > 0) {\n      return true;\n    }\n\n    return false;\n  };\n\n  GestureController.prototype.newID = function () {\n    this.gestureId++;\n    return this.gestureId;\n  };\n\n  return GestureController;\n}();\n\nvar GestureDelegate =\n/** @class */\nfunction () {\n  function GestureDelegate(ctrl, id, name, priority, disableScroll) {\n    this.id = id;\n    this.name = name;\n    this.priority = priority;\n    this.disableScroll = disableScroll;\n    this.ctrl = ctrl;\n  }\n\n  GestureDelegate.prototype.canStart = function () {\n    if (!this.ctrl) {\n      return false;\n    }\n\n    return this.ctrl.canStart(this.name);\n  };\n\n  GestureDelegate.prototype.start = function () {\n    if (!this.ctrl) {\n      return false;\n    }\n\n    return this.ctrl.start(this.name, this.id, this.priority);\n  };\n\n  GestureDelegate.prototype.capture = function () {\n    if (!this.ctrl) {\n      return false;\n    }\n\n    var captured = this.ctrl.capture(this.name, this.id, this.priority);\n\n    if (captured && this.disableScroll) {\n      this.ctrl.disableScroll(this.id);\n    }\n\n    return captured;\n  };\n\n  GestureDelegate.prototype.release = function () {\n    if (this.ctrl) {\n      this.ctrl.release(this.id);\n\n      if (this.disableScroll) {\n        this.ctrl.enableScroll(this.id);\n      }\n    }\n  };\n\n  GestureDelegate.prototype.destroy = function () {\n    this.release();\n    this.ctrl = undefined;\n  };\n\n  return GestureDelegate;\n}();\n\nvar BlockerDelegate =\n/** @class */\nfunction () {\n  function BlockerDelegate(id, ctrl, disable, disableScroll) {\n    this.id = id;\n    this.disable = disable;\n    this.disableScroll = disableScroll;\n    this.ctrl = ctrl;\n  }\n\n  BlockerDelegate.prototype.block = function () {\n    if (!this.ctrl) {\n      return;\n    }\n\n    if (this.disable) {\n      for (var _i = 0, _b = this.disable; _i < _b.length; _i++) {\n        var gesture = _b[_i];\n        this.ctrl.disableGesture(gesture, this.id);\n      }\n    }\n\n    if (this.disableScroll) {\n      this.ctrl.disableScroll(this.id);\n    }\n  };\n\n  BlockerDelegate.prototype.unblock = function () {\n    if (!this.ctrl) {\n      return;\n    }\n\n    if (this.disable) {\n      for (var _i = 0, _b = this.disable; _i < _b.length; _i++) {\n        var gesture = _b[_i];\n        this.ctrl.enableGesture(gesture, this.id);\n      }\n    }\n\n    if (this.disableScroll) {\n      this.ctrl.enableScroll(this.id);\n    }\n  };\n\n  BlockerDelegate.prototype.destroy = function () {\n    this.unblock();\n    this.ctrl = undefined;\n  };\n\n  return BlockerDelegate;\n}();\n\nvar gestureController = new GestureController(document);\n\nvar _sPassive;\n\nfunction supportsPassive(node) {\n  if (_sPassive === undefined) {\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          _sPassive = true;\n        }\n      });\n      node.addEventListener('optsTest', function () {\n        return;\n      }, opts);\n    } catch (_a) {\n      _sPassive = false;\n    }\n  }\n\n  return !!_sPassive;\n}\n\nfunction addEventListener(el, eventName, callback, opts) {\n  // use event listener options when supported\n  // otherwise it's just a boolean for the \"capture\" arg\n  var listenerOpts = supportsPassive(el) ? {\n    'capture': !!opts.capture,\n    'passive': !!opts.passive\n  } : !!opts.capture;\n  var add;\n  var remove;\n\n  if (el['__zone_symbol__addEventListener']) {\n    add = '__zone_symbol__addEventListener';\n    remove = '__zone_symbol__removeEventListener';\n  } else {\n    add = 'addEventListener';\n    remove = 'removeEventListener';\n  }\n\n  el[add](eventName, callback, listenerOpts);\n  return function () {\n    el[remove](eventName, callback, listenerOpts);\n  };\n}\n\nvar MOUSE_WAIT = 2000;\n\nfunction createPointerEvents(el, pointerDown, pointerMove, pointerUp, options) {\n  var rmTouchStart;\n  var rmTouchMove;\n  var rmTouchEnd;\n  var rmTouchCancel;\n  var rmMouseStart;\n  var rmMouseMove;\n  var rmMouseUp;\n  var lastTouchEvent = 0;\n\n  function handleTouchStart(ev) {\n    lastTouchEvent = Date.now() + MOUSE_WAIT;\n\n    if (!pointerDown(ev)) {\n      return;\n    }\n\n    if (!rmTouchMove && pointerMove) {\n      rmTouchMove = addEventListener(el, 'touchmove', pointerMove, options);\n    }\n\n    if (!rmTouchEnd) {\n      rmTouchEnd = addEventListener(el, 'touchend', handleTouchEnd, options);\n    }\n\n    if (!rmTouchCancel) {\n      rmTouchCancel = addEventListener(el, 'touchcancel', handleTouchEnd, options);\n    }\n  }\n\n  function handleMouseDown(ev) {\n    if (lastTouchEvent > Date.now()) {\n      console.debug('mousedown event dropped because of previous touch');\n      return;\n    }\n\n    if (!pointerDown(ev)) {\n      return;\n    }\n\n    if (!rmMouseMove && pointerMove) {\n      rmMouseMove = addEventListener(getDocument(el), 'mousemove', pointerMove, options);\n    }\n\n    if (!rmMouseUp) {\n      rmMouseUp = addEventListener(getDocument(el), 'mouseup', handleMouseUp, options);\n    }\n  }\n\n  function handleTouchEnd(ev) {\n    stopTouch();\n\n    if (pointerUp) {\n      pointerUp(ev);\n    }\n  }\n\n  function handleMouseUp(ev) {\n    stopMouse();\n\n    if (pointerUp) {\n      pointerUp(ev);\n    }\n  }\n\n  function stopTouch() {\n    if (rmTouchMove) {\n      rmTouchMove();\n    }\n\n    if (rmTouchEnd) {\n      rmTouchEnd();\n    }\n\n    if (rmTouchCancel) {\n      rmTouchCancel();\n    }\n\n    rmTouchMove = rmTouchEnd = rmTouchCancel = undefined;\n  }\n\n  function stopMouse() {\n    if (rmMouseMove) {\n      rmMouseMove();\n    }\n\n    if (rmMouseUp) {\n      rmMouseUp();\n    }\n\n    rmMouseMove = rmMouseUp = undefined;\n  }\n\n  function stop() {\n    stopTouch();\n    stopMouse();\n  }\n\n  function setDisabled(disabled) {\n    if (disabled) {\n      if (rmTouchStart) {\n        rmTouchStart();\n      }\n\n      if (rmMouseStart) {\n        rmMouseStart();\n      }\n\n      rmTouchStart = rmMouseStart = undefined;\n      stop();\n    } else {\n      if (!rmTouchStart) {\n        rmTouchStart = addEventListener(el, 'touchstart', handleTouchStart, options);\n      }\n\n      if (!rmMouseStart) {\n        rmMouseStart = addEventListener(el, 'mousedown', handleMouseDown, options);\n      }\n    }\n  }\n\n  function destroy() {\n    setDisabled(true);\n    pointerUp = pointerMove = pointerDown = undefined;\n  }\n\n  return {\n    setDisabled: setDisabled,\n    stop: stop,\n    destroy: destroy\n  };\n}\n\nfunction getDocument(node) {\n  return node instanceof Document ? node : node.ownerDocument;\n}\n\nfunction createPanRecognizer(direction, thresh, maxAngle) {\n  var radians = maxAngle * (Math.PI / 180);\n  var isDirX = direction === 'x';\n  var maxCosine = Math.cos(radians);\n  var threshold = thresh * thresh;\n  var startX = 0;\n  var startY = 0;\n  var dirty = false;\n  var isPan = 0;\n  return {\n    start: function start(x, y) {\n      startX = x;\n      startY = y;\n      isPan = 0;\n      dirty = true;\n    },\n    detect: function detect(x, y) {\n      if (!dirty) {\n        return false;\n      }\n\n      var deltaX = x - startX;\n      var deltaY = y - startY;\n      var distance = deltaX * deltaX + deltaY * deltaY;\n\n      if (distance < threshold) {\n        return false;\n      }\n\n      var hypotenuse = Math.sqrt(distance);\n      var cosine = (isDirX ? deltaX : deltaY) / hypotenuse;\n\n      if (cosine > maxCosine) {\n        isPan = 1;\n      } else if (cosine < -maxCosine) {\n        isPan = -1;\n      } else {\n        isPan = 0;\n      }\n\n      dirty = false;\n      return true;\n    },\n    isGesture: function isGesture() {\n      return isPan !== 0;\n    },\n    getDirection: function getDirection() {\n      return isPan;\n    }\n  };\n}\n\nfunction createGesture(config) {\n  var finalConfig = Object.assign({\n    disableScroll: false,\n    direction: 'x',\n    gesturePriority: 0,\n    passive: true,\n    maxAngle: 40,\n    threshold: 10\n  }, config);\n  var canStart = finalConfig.canStart;\n  var onWillStart = finalConfig.onWillStart;\n  var onStart = finalConfig.onStart;\n  var onEnd = finalConfig.onEnd;\n  var notCaptured = finalConfig.notCaptured;\n  var onMove = finalConfig.onMove;\n  var threshold = finalConfig.threshold;\n  var queue = finalConfig.queue;\n  var detail = {\n    type: 'pan',\n    startX: 0,\n    startY: 0,\n    startTimeStamp: 0,\n    currentX: 0,\n    currentY: 0,\n    velocityX: 0,\n    velocityY: 0,\n    deltaX: 0,\n    deltaY: 0,\n    timeStamp: 0,\n    event: undefined,\n    data: undefined\n  };\n  var pointerEvents = createPointerEvents(finalConfig.el, pointerDown, pointerMove, pointerUp, {\n    capture: false\n  });\n  var pan = createPanRecognizer(finalConfig.direction, finalConfig.threshold, finalConfig.maxAngle);\n  var gesture = gestureController.createGesture({\n    name: config.gestureName,\n    priority: config.gesturePriority,\n    disableScroll: config.disableScroll\n  });\n  var hasCapturedPan = false;\n  var hasStartedPan = false;\n  var hasFiredStart = true;\n  var isMoveQueued = false;\n\n  function pointerDown(ev) {\n    var timeStamp = now(ev);\n\n    if (hasStartedPan || !hasFiredStart) {\n      return false;\n    }\n\n    updateDetail(ev, detail);\n    detail.startX = detail.currentX;\n    detail.startY = detail.currentY;\n    detail.startTimeStamp = detail.timeStamp = timeStamp;\n    detail.velocityX = detail.velocityY = detail.deltaX = detail.deltaY = 0;\n    detail.event = ev; // Check if gesture can start\n\n    if (canStart && canStart(detail) === false) {\n      return false;\n    } // Release fallback\n\n\n    gesture.release(); // Start gesture\n\n    if (!gesture.start()) {\n      return false;\n    }\n\n    hasStartedPan = true;\n\n    if (threshold === 0) {\n      return tryToCapturePan();\n    }\n\n    pan.start(detail.startX, detail.startY);\n    return true;\n  }\n\n  function pointerMove(ev) {\n    // fast path, if gesture is currently captured\n    // do minimun job to get user-land even dispatched\n    if (hasCapturedPan) {\n      if (!isMoveQueued && hasFiredStart) {\n        isMoveQueued = true;\n        calcGestureData(detail, ev);\n        queue.write(fireOnMove);\n      }\n\n      return;\n    } // gesture is currently being detected\n\n\n    calcGestureData(detail, ev);\n\n    if (pan.detect(detail.currentX, detail.currentY)) {\n      if (!pan.isGesture() || !tryToCapturePan()) {\n        abortGesture();\n      }\n    }\n  }\n\n  function fireOnMove() {\n    // Since fireOnMove is called inside a RAF, onEnd() might be called,\n    // we must double check hasCapturedPan\n    if (!hasCapturedPan) {\n      return;\n    }\n\n    isMoveQueued = false;\n\n    if (onMove) {\n      onMove(detail);\n    }\n  }\n\n  function tryToCapturePan() {\n    if (gesture && !gesture.capture()) {\n      return false;\n    }\n\n    hasCapturedPan = true;\n    hasFiredStart = false; // reset start position since the real user-land event starts here\n    // If the pan detector threshold is big, not reseting the start position\n    // will cause a jump in the animation equal to the detector threshold.\n    // the array of positions used to calculate the gesture velocity does not\n    // need to be cleaned, more points in the positions array always results in a\n    // more acurate value of the velocity.\n\n    detail.startX = detail.currentX;\n    detail.startY = detail.currentY;\n    detail.startTimeStamp = detail.timeStamp;\n\n    if (onWillStart) {\n      onWillStart(detail).then(fireOnStart);\n    } else {\n      fireOnStart();\n    }\n\n    return true;\n  }\n\n  function fireOnStart() {\n    if (onStart) {\n      onStart(detail);\n    }\n\n    hasFiredStart = true;\n  }\n\n  function abortGesture() {\n    reset();\n    pointerEvents.stop();\n\n    if (notCaptured) {\n      notCaptured(detail);\n    }\n  }\n\n  function reset() {\n    hasCapturedPan = false;\n    hasStartedPan = false;\n    isMoveQueued = false;\n    hasFiredStart = true;\n    gesture.release();\n  } // END *************************\n\n\n  function pointerUp(ev) {\n    var tmpHasCaptured = hasCapturedPan;\n    var tmpHasFiredStart = hasFiredStart;\n    reset();\n\n    if (!tmpHasFiredStart) {\n      return;\n    }\n\n    calcGestureData(detail, ev); // Try to capture press\n\n    if (tmpHasCaptured) {\n      if (onEnd) {\n        onEnd(detail);\n      }\n\n      return;\n    } // Not captured any event\n\n\n    if (notCaptured) {\n      notCaptured(detail);\n    }\n  }\n\n  return {\n    setDisabled: function setDisabled(disabled) {\n      pointerEvents.setDisabled(disabled);\n    },\n    destroy: function destroy() {\n      gesture.destroy();\n      pointerEvents.destroy();\n    }\n  };\n}\n\nfunction calcGestureData(detail, ev) {\n  var prevX = detail.currentX;\n  var prevY = detail.currentY;\n  var prevT = detail.timeStamp;\n  updateDetail(ev, detail);\n  var currentX = detail.currentX;\n  var currentY = detail.currentY;\n  var timestamp = detail.timeStamp = now(ev);\n  var timeDelta = timestamp - prevT;\n\n  if (timeDelta > 0 && timeDelta < 100) {\n    var velocityX = (currentX - prevX) / timeDelta;\n    var velocityY = (currentY - prevY) / timeDelta;\n    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;\n    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;\n  }\n\n  detail.deltaX = currentX - detail.startX;\n  detail.deltaY = currentY - detail.startY;\n  detail.event = ev;\n}\n\nfunction updateDetail(ev, detail) {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  var x = 0;\n  var y = 0;\n\n  if (ev) {\n    var changedTouches = ev.changedTouches;\n\n    if (changedTouches && changedTouches.length > 0) {\n      var touch = changedTouches[0];\n      x = touch.clientX;\n      y = touch.clientY;\n    } else if (ev.pageX !== undefined) {\n      x = ev.pageX;\n      y = ev.pageY;\n    }\n  }\n\n  detail.currentX = x;\n  detail.currentY = y;\n}\n\nfunction now(ev) {\n  return ev.timeStamp || Date.now();\n}\n\nexport { createGesture };"],"sourceRoot":""}